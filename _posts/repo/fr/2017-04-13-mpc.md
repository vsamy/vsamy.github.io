---
layout: post_page
lang: fr
ref: repo
post_url: mpc
title: Copra
permalink: fr/git-repository/copra
---

Cette librairie a été développée pour résoudre le problème du contrôle prédictif. 
Elle résout des systèmes discrets en utilisant un QP.
La librairie a été conçue de manière à être performante et facile à utiliser.
De plus, des bindings python permettent son utilisation dans un environnment python.

C'est ma première gosse librairie !
Dans cet artcile, je vais décrire en quoi un mpc est utile, pourquoi l'utiliser er comment.
<!--more-->

# Un MPC, c'est quoi ?
MPC est l'acronyme de `Model Predictive Control` ou en français `Modèle de Contrôle Prédictif`.
C'est utile pour trouver une solution dans un horizon de temps donné, cela en minimisant une fonction de coût.
La librairie ne peut que résoudre des systèmes linéaires invariants dans le temps i.e. le système ne change pas de comportement dans le temps.

De manière plus simple, un mpc est fait pour rechercher une trajectoire qui mène à un point désiré ou encore de rechercher le contrôle à appliquer pour une trajectoire donnée.

## Systèmes continus
Habituellement, tout commence par un beau système linéaire.
Comme il est difficile de résoudre le problème analytiquement et rapidement, il faut discrétiser le système qui devient alors résoluble par le mpc.

Regardons tout d'abord quels types de système peuvent convenir.
Tout système de la forme

$$ \mathbf{\dot{s}} = A\_c\mathbf{s} + B\_c\mathbf{u} + \mathbf{d}\_c $$

convient. \\(\mathbf{s}\\) est le vecteur d'état du système et \\(\mathbf{u}\\) le vecteur de contrôle.
Après discrétisation d'un pas de temps \\(T\\), le système devient :

$$ \mathbf{s}\_{k+1} = A\mathbf{s}\_k + B\mathbf{u}\_k + \mathbf{d} $$

où \\(A\\), \\(B\\) et \\(\mathbf{d}\\) sont respectivement la matrice d'état, la matrice de contrôle et le biais. Pour comprendre comment discrétiser son système [rien de mieux qu'une page Wikipédia](https://en.wikipedia.org/wiki/Discretization)

## Comment calculer le futur ?

Pour expliquer comment le mpc trouve une solution, il faut d'abord trouver la récurrence des équation ci-dessus.
Aux premières étapes, on a

$$
\begin{eqnarray}
    \mathbf{x}\_1 & = & A\mathbf{x}\_0 + B\mathbf{u}\_0 + \mathbf{d} \\\\
    \mathbf{x}\_2 & = & A\mathbf{x}\_1 + B\mathbf{u}\_1 + \mathbf{d} \\\\
                  & = & A(A\mathbf{x}\_0 + B\mathbf{u}\_0 + \mathbf{d}) + B\mathbf{u}\_1 + \mathbf{d} \\\\
                  & = & A^2\mathbf{x}\_0 + [AB\ B][\mathbf{u}^T\_0\ \mathbf{u}^T\_1]^T + A\mathbf{d} + \mathbf{d} \\\\
    \mathbf{x}\_3 & = & A\mathbf{x}\_2 + B\mathbf{u}\_2 + \mathbf{d} \\\\
                  & = & A(A^2\mathbf{x}\_0 + [AB\ B][\mathbf{u}^T\_0\ \mathbf{u}^T\_1]^T + A\mathbf{d} + \mathbf{d}) + B\mathbf{u}\_1 + \mathbf{d} \\\\
                  & = & A^3\mathbf{x}\_0 + [A^2B\ AB\ B][\mathbf{u}^T\_0\ \mathbf{u}^T\_1\ \mathbf{u}^T\_2]^T + A^2\mathbf{d} + A\mathbf{d} + \mathbf{d}
\end{eqnarray}.
$$

Ainsi, on voit assez facilement (on passera la démonstration ici) qu'à la \\(N\\)-ième étape on a:

$$ \mathbf{X}\_N = \Phi\mathbf{x}\_0 + \Psi\mathbf{U}\_{N-1} + \mathbf{\xi} $$

avec

$$
\Phi = \left[
    \begin{array}{c}
        I \\\\
        A \\\\
        A^2 \\\\
        \vdots \\\\
        A^N
    \end{array}
    \right],
\ \Psi = \left[
    \begin{array}{cccc}
        0        & 0        & \cdots & 0 \\\\
        B        & 0        & \cdots & 0 \\\\
        AB       & B        & \ddots & \vdots \\\\
        \vdots   & \vdots   & \ddots & 0 \\\\
        A^{N-1}B & A^{N-2}B & \cdots & B
    \end{array}
    \right],
\ \mathbf{\xi} = \left[
    \begin{array}{c}
        \mathbf{0} \\\\
        \mathbf{d} \\\\
        A\mathbf{d} + \mathbf{d} \\\\
        \vdots \\\\
        \sum\_{i=0}^{N-1} A^{i}\mathbf{d}
    \end{array}
    \right]
$$

et le vecteur d'état total \\(\mathbf{X}\\) et le vecteur de contrôle total \\(\mathbf{U}\\) sont

$$
\mathbf{X} = \left[
    \begin{array}{c}
        \mathbf{x}\_0 \\\\
        \mathbf{x}\_1 \\\\
        \vdots \\\\
        \mathbf{x}\_N
    \end{array}
    \right],
\ \mathbf{U} = \left[
    \begin{array}{c}
        \mathbf{u}\_0 \\\\
        \mathbf{u}\_1 \\\\
        \vdots \\\\
        \mathbf{u}\_{N-1}
    \end{array}
    \right].
$$

Finalement, considérant une valeur désirée/une trajectoire désirée \\(\mathbf{X}\_T\\) on calcule sur l'horizon de temps choisi et considérant une fonction de coût.

# La librairie de plus près
La compréhension des matrices ci-dessus est importante car elle permet de mieux cerner le fonctionnement de la librairie.
Son développement a été fait avec les outills de c++14. Hormis la librairie c++ standard, j'ai utilisé [eigen](http://eigen.tuxfamily.org) pour la gestion des matrices.
Enfin, et pour la suite, on appelle matrice-pas (resp. vecteur-pas) une matrice (resp. un vecteur) de la dimension d'un pas de temps et matrice-total (resp. vecteur-total) une matrice (resp. un vecteur) de la dimension de tous les pas de temps.

## The system
The system is written in the `PreviewSystem.h` file.
It defines the whole system and creates the \\(\Phi\\), \\(\Psi\\) and \\(\mathbf{\xi}\\) matrices and vector.
It is better to create a shared pointer of the instance.

```c++
auto ps = std::make_shared<copra::PreviewSystem>();
// Initialize the system
ps->system(A, B, d, x_0, nrStep);
// Initialize the system in the constructor
auto ps = std::make_shared<copra::PreviewSystem>(A, B, d, x_0, nrStep);
```

## The mpc
The mpc is written in the `LMPC.h` file.
Creating an instance of an mpc is also fairly easy.

```c++
copra::LMPC controller(ps);
// Build the system and solve the mpc
controller.solve();
```

It is also possible to (re)initialize the system used by the copra.

```c++
copra::LMPC controller();
// (Re)initialize the mpc with the new system
controller.initializeController(ps);
```

To get the results, you just need to call it :)

```c++
Eigen::VectorXd trajectory = controller.trajectory();
Eigen::VectorXd control = controller.control();
```

## The constraints
The library provides several types of constraints.
All the constraints can be created using step-matrix or whole-matrix.
We will see that a mixed of the two is also possible.
They also need to be wrapped in a shared pointer in order to be passed to the copra.

### Trajectory Constraints
We distinguish two types of trajectory constraints: The trajectory constraint \\(E\mathbf{X} \leq \mathbf{f}\\) or \\(E\mathbf{X} = \mathbf{f}\\)
and the trajectory bound constraint \\(\underline{\mathbf{X}} \leq \mathbf{X} \leq \overline{\mathbf{X}}\\).
Note that the latter can be rewritten to produce the former.

```c++
// Create an inequality constraint
// E is step-matrix or whole-matrix, f is step-vector or whole-vector.
auto ineqTrajConstr = std::make_shared<copra::TrajectoryConstraint>(E, f);
// Create an equality constraint
auto eqTrajConstr = std::make_shared<copra::TrajectoryConstraint>(E, f, false);
// Create a bound constraint
// lower and upper are step-vector or whole-vector
auto boundTrajConstr = std::make_shared<copra::TrajectoryBoundConstraint>(lower, upper);
```

Note: to assign infinite born, you have to include the stl `<limits>` and use `std::numeric_limits<double>::max()`. In python side, you have to use `float('Inf')`.

### Control Constraints
This is pretty much the same idea as above, there is two type: The control constraint \\(G\mathbf{U} \leq \mathbf{f}\\) or \\(G\mathbf{U} = \mathbf{f}\\)
and the control bound constraint \\(\underline{\mathbf{U}} \leq \mathbf{U} \leq \overline{\mathbf{U}}\\).

```c++
// Create an inequality constraint
// G is step-matrix or whole-matrix, f is step-vector or whole-vector.
auto ineqControlConstr = std::make_shared<copra::ControlConstraint>(E, f);
// Create an equality constraint
auto eqControlConstr = std::make_shared<copra::ControlConstraint>(E, f, false);
// Create a bound constraint
// lower and upper are step-vector or whole-vector
auto boundControlConstr = std::make_shared<copra::ControlBoundConstraint>(lower, upper);
```

### Mixed Constraints
Mixed constraints allow you to add constraints that involve both the trajectory and the control.
It is written as \\(E\mathbf{X} + G\mathbf{U} \leq \mathbf{f}\\) or \\(E\mathbf{X} + G\mathbf{U} = \mathbf{f}\\).
As always:

```c++
// Create an inequality constraint
// E is step-matrix or whole-matrix,  G is step-matrix or whole-matrix, f is step-vector or whole-vector.
auto ineqMixedConstr = std::make_shared<copra::MixedConstraint>(E, G, f);
// Create an equality constraint
auto eqMixedConstr = std::make_shared<copra::MixedConstraint>(E, G, f, false);
```

### Adding and updating a constraint
All that needs to be done is to make the mpc aware of the constraints.
It will update the constraints when its solve function is called.

```c++
// Adding an inequality control constraint
controller.addConstraint(ineqControlConstr);
```

## Cost functions
As for constraints, the library provides several types of cost functions.
All the costs can be created using step-matrix or whole-matrix.
They also need to be wrapped in a shared pointer in order to be passed to the mpc and may more than one.

### Target Cost
The target cost function minimizes \\(\|\|M\mathbf{x}_N + \mathbf{p}\|\|\\).
\\(M\\) must be a step-matrix and \\(p\\) must be a step-vector.

```c++
// Create a target cost
auto targetCost = std::make_shared<copra::TargetCost>(M, p);
```

### Trajectory Cost
The trajectory cost function minimizes \\(\|\|M\mathbf{X} + \mathbf{p}\|\|\\).

```c++
// Create a trajectory cost
// M is step-matrix or whole-matrix, p is step-vector or whole-vector.
auto trajectoryCost = std::make_shared<copra::TrajectoryCost>(M, p);
```

### Control Cost
The control cost minimizes \\(\|\|N\mathbf{U} + \mathbf{p}\|\|\\).

```c++
// Create a control cost
// M is step-matrix or whole-matrix, p is step-vector or whole-vector.
auto ControlCost = std::make_shared<copra::ControlCost>(N, p);
```

### Mixed Cost
The mixed cost minimizes \\(\|\|N\mathbf{X} + N\mathbf{U} + \mathbf{p}\|\|\\).

```c++
// Create a mixed cost
// M is step-matrix or whole-matrix, N is step-matrix or whole-matrix, p is step-vector or whole-vector.
auto mixedCost = std::make_shared<copra::MixedCost>(M, N, p);
```

## Cost and constraint specificities
There are several helper tools for cost functions and constraints.

### Removal
There are two ways of deleting a constraint from the copra.
The main way is to let the mpc handles it.
In the `solve` function and at the end, the mpc checks whether or not a constraint needs to be deleted.
A constraint is deleted if the user (you) has deleted his shared pointer of the constraint.
If you keep a shared pointer of the constraint alive, the constraint remains in the copra.
Another way is to call the function `removeCost` and `removeConstraint`

### The autoSpan function
The `autoSpan` function is present in all constraints and cost.
This method needs to be called if you have created a constraint that mixes step-matrix/vector with whole-matrix/vector.
For example, if you have a constant step-matrix \\(G\\) and a whole-vector \\(\mathbf{f}\\), 
you can pass the two matrices to the constraint and then call the autoSpan function.

## Changing the QP solver
Depending on your compilation state, 4 QP solvers are implemented.
You can change at anytime the QP to use for solving your problem.
The current available QP are:

 * QuadProg (Default one)
 * QLD
 * Gurobi
 * LSSOL (need commercial license)

To change the QP:

```c++
// Create an instance of a mpc with a different QP
copra::LMPC controller(copra::SolverFlag::QLD)
// Change the QP at any time
controller.selectQPSolver(copra::SolverFlag::GUROBIDense)
```

If the default setting of a QP solver is not enough, it is possible to give the controller a user-defined QP.

```c++
// Create your QP
std::unique_ptr<Eigen::QLD> solver = solverFactory(copra::SolverFlag::QLD);
// Make change here
solver->SI_feasibilityTolerance(1e-8);
// ...
// Give it to the QP
controller.useSolver(std::move(solver));
```

## Python users
Python users can use all the library, the same way as C++ users.
There are some change though.
As a shared pointer of constraints and preview system are needed, a specific function has been developed.
Python users need to call the function with `New` in front.
For example, `PreviewSystem()` becomes `NewPreviewSystem()`.
The lib minieigen provides all the tools needed to use Eigen in Python.

## Improving performance and building time
First, you can measure building and solving time of the mpc using `solveTime()` and `solveAndBuildTime()` functions.
This computes internally the time needed to build the problem and to solve it.

### Updating the system yourself
The initialization of the preview system is just meant to allocate memory for all the needed matrices (\\(\Phi\\), \\(\Psi\\), etc...)
Normally, when calling the `solve()` function of the mpc, there is no need to do anything else. 
If those matrices are not updated yet, then they will be built before solving the problem.
In the case you can (and want to) update the system yourself, you just need to call the `updateSystem()` function of the preview system.
The `solve()` function will be then faster since it does not have to build the preview system.

Note that you have a full control of the preview system.
You can voluntary modify the matrices inside the preview system if you have specific matrices.
Don't forget to (re)initialize the mpc if you have changed the dimension of the problem.

### Give rvalue to the constraints and costs
Constraints constructor and weights functions use universal reference to allow move semantic of rvalue and copy of lvalue. 
In the case you don't need to keep the constraint matrices, prefer rvalue as parameters. This feature is not available for python users.

### Privilege step-matrix and step-vector
The library lets you use both step-matrix/vector and whole-matrix/vector.
When only step-matrix and step-vector are given and because of the sparsity of the problem, the computation will run faster.
Note that for some constraints (control constraints and bound constraints) a move is perform for whole-matrix/vector. 

Sparse matrix will be used to improve performance in future release.

## Pymanoid
[Pymanoid](https://github.com/stephane-caron/pymanoid) is library developed in python by [Stéphane Caron](https://scaron.info/) which allows you to use the model preview controller for motion planning and ele.